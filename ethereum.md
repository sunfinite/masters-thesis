## Node discovery

Every node in ethereum has a private key. On start, the node looks for this key in file ``<datadir>/geth/nodekey`` <footnote>. If this file is not present, it generates a  32-byte key using the secp256k1 elliptic curve algorithm <cite> and stores it to this file. Note that this key is separate from private keys associated with accounts that may be local to this node, for example the node's coinbase account if it is a miner. The corresponding public key becomes this node's ID. This ID is then used to construct a node designator of the form "enode://<node ID>@<node IP>:<node Port>". We have the option of using a different port for node discovery separate from the port used for general node-to-node communication. The discovery protocol uses UDP whereas node-to-node communication uses Ethereum's home-rolled RLPx on top of TCP. If these two ports are separate, the node designator will be of the form "enode://<node ID>@<node IP>:<TCP Port>?discport=<UDP Port>".
  
A separate list of nodes designators for each of Ethereum's networks (Mainnet, Testnet and Rinkleby) are configured as boot nodes in code. On choosing a network, bonding is initiated with each node in the appropriate list. Bonding consists of sending a Ping message and waiting for a Pong (see below for structure of these messages). Upon receipt of a successful Pong, a FindNode message is sent to this peer. The peer responds with a subset of its current peers. 

Peer information obtained in this fashion is maintained in an in-memory key value data store by default (this can be changed to on disk). Ethereum uses a routing (?) scheme based on Kademlia <cite> to rank peers. 
